##1. Что выведет программа? Объяснить вывод программы.
```
package main

import (
    "fmt"
)

func main() {
    a := [5]int{76, 77, 78, 79, 80}
    var b []int = a[1:4]
    fmt.Println(b)
}
```

Вывод: [77, 78, 79] срез выражается через наполовину открытый диапазон, поэтому элемент с индексом 4 не попал в срез.

##2. Что выведет программа? Объяснить вывод программы. Объяснить как работают defer’ы и порядок их вызовов.
```
package main

import (
	"fmt"
)

func test() (x int) {
	defer func() {
		x++
	}()
	x = 1
	return
}

func anotherTest() int {
	var x int
	defer func() {
		x++
	}()
	x = 1
	return x
}

func main() {
	fmt.Println(test())
	fmt.Println(anotherTest())
}
```
Вывод: 2 1

defer позволяет отложить выполнение функции перед которой он обьявлен, выполнение отложенной функции происходит после того как инструкция возврата обновляет результат функции. Если обьявлено несколько defer они будут вызываться в порядке обратном обьявлению (FILO).

В функции test используется именованный результат, такие результаты рассматриваются как переменные объявленные в начале функции, defer может изменять результат таких переменных, так как вызывается до фактического возврата из функции. 

##3. Что выведет программа? Объяснить вывод программы. Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.
```
package main

import (
	"fmt"
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println(err)
	fmt.Println(err == nil)
}
```
Вывод: false

Внутри интрефейс устроен как структура состоящая из динамического типа и указателя на данные:
```
type iface struct {
	tab  *itab
	data unsafe.Pointer
}
```
Так как переменная имеет интерфейсный тип *os.PathError, указатель tab указывающий на interface table не пустой, там хранится информация о типе и список методов, а значит сравнение с nil дает false.

Пустой интерфейс interface{} не имеет методов, следовательно ему удовлетворяет любой обьект.

Поскольку пустой интерфейс не имеет методов - в памяти он выглядит иначе - он не содержит списка методов, а только хранит информацию о типе:
```
type emptyInterface struct {
	typ  *rtype
	word unsafe.Pointer
}
```

##4. Что выведет программа? Объяснить вывод программы.
```
package main

func main() {
    ch := make(chan int)
    
    go func() {
        for i := 0; i < 10; i++ {
            ch <- i
        }
    }()

    for n := range ch {
        println(n)
    }
}
```
Будут выведены значения цикла, после чего программа завершиться с ошибкой all goroutines are asleep - deadlock!

range по каналу читает данные пока канал не закроется, соответственно произойдет deadlock.

##5. Что выведет программа? Объяснить вывод программы.
```
package main

type customError struct {
    msg string
}

func (e *customError) Error() string {
    return e.msg
}

func test() *customError {
    {
        // do something
    }   
    return nil
}

func main() {
    var err error
    err = test()
    if err != nil {
        println("error")
        return  
    }
    
    println("ok")
}
```
Присваивание err = test() включает в себя неявное преобразование результата функции с типом *customError и значением nil к интерфейсу error. Далее мы сравниваем значение интерфейсного типа (error, nil) с nil и получаем false.

##6. Что выведет программа? Объяснить вывод программы. Рассказать про внутреннее устройство слайсов и что происходит при передаче их в качестве аргументов функции.
```
package main

import (
    "fmt"
)

func main() {
    var s = []string{"1", "2", "3"}
    modifySlice(s)
    fmt.Println(s)
}

func modifySlice(i []string) {
    i[0] = "3"
    i = append(i, "4")
    i[1] = "5"
    i = append(i, "6")
}
```
Вывод: [3 2 3]

Слайс - это структура состоящая из 3 полей (указатель на первый доступный элемент массива, длина, емкость).

В го все передается по значению, когда мы передаем слайс в функцию - мы передаем копию структуры.

Первый элемент слайса изменился по указателю на массив. Далее при вызове append базовый массив был перевыделен, так как емкость превысила допустимую при добавлениии. Следовательно, дальнейшие изменения слайса по индексу (i[1] = "5") не отразились на его оригинале. 

Новые элементы не были добавлены в оригинальный слайс (4 и 6), так как функция работала с копией слайса.

##7. Что выведет программа? Объяснить вывод программы.
```
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func asChan(vs ...int) <-chan int {
	c := make(chan int)
	go func() {
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) *
				time.Millisecond)
		}
		close(c)
	}()
	return c
}

func merge(a, b <-chan int) <-chan int {
	c := make(chan int)
	go func() {
		for {
			select {
			case v := <-a:
				c <- v
			case v := <-b:
				c <- v
			}
		}
	}()
	return c
}

func main() {
	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4, 6, 8)
	c := merge(a, b)
	for v := range c {
		fmt.Println(v)
	}
}
```
Будут выведены значения из каналов a и b в неопределенном порядке, затем после закрытия каналов будут выводиться 0 при чтении из закрытого канала.
